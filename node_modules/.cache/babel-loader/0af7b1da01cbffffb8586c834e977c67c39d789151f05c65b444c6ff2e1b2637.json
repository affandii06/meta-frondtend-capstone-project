{"ast":null,"code":"/**\n * Compares Two Dates against each other with any offset and\n * returns whether the first date is still lesser than the second with offset factored in.\n * @param {Date} startDate\n * @param {Date} endDate\n * @param {Number} offsetDays\n * @returns `boolean`\n *\n * Examples:\n * ---------\n * `compareDates('2023/01/30', '2023/01/31', 1);` ==> `false`\n * `compareDates('2023/01/28', '2023/01/31', 2);` ==> `true`\n * `console.log(compareDates(Date.now(), '2023/02/12', 1));` ==> true\n */\nexport const compareDates = function (startDate, endDate) {\n  let offsetDays = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  const d1 = new Date(startDate);\n  const d2 = new Date(endDate);\n  if (!parseInt(offsetDays)) return d1 < d2;else {\n    d1.setDate(d1.getDate() + Math.round(Math.max(offsetDays, 0)));\n    return d1 < d2;\n  }\n};\n\n/**\n * Gets the current date and time formatted for the HTML Input date and time fields.\n * Takes in an offsetDays to return a date in the future or past.\n * @param {number} offset\n * @returns\n */\nexport const currentDateTime = function () {\n  let offsetDays = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  const dateTime = new Date();\n  dateTime.setDate(dateTime.getDate() + Math.round(offsetDays));\n  const date = dateTime.toLocaleDateString();\n  const time = dateTime.toLocaleTimeString();\n  return {\n    date: date.split('/').reverse().join('-'),\n    time: time.slice(0, time.lastIndexOf(':'))\n  };\n};\n\n/**\n * Given time in the format: `21:00` or `12:58:37`, convert the time to milliseconds.\n * @param {string} time\n * @returns\n */\nexport const convertToMilliseconds = time => {\n  const tArr = time.split(':');\n  return tArr.reduce((acc, num, index) => {\n    if (index > 1) return acc + num;\n    return acc + num * Math.pow(60, tArr.length - index);\n  }, 0);\n};\n\n/**\n * Takes a `startTime` and an `endTime` and compares them against a time to check if it\n * is a valid time of if doesn't fall within the time period.\n * @param {string} startTime\n * @param {string} endTime\n * @param {string} value\n * @returns `boolean`\n */\nexport const withinReservationHours = (startTime, endTime, value) => {\n  const t1 = convertToMilliseconds(startTime);\n  const t2 = convertToMilliseconds(endTime);\n  const v = convertToMilliseconds(value);\n  return v >= t1 && v <= t2;\n};\n\n// console.log(withinReservationHours('11:00', '21:00', '11:00')); // true\n// console.log(withinReservationHours('11:00', '21:00', '21:00')); // true\n// console.log(withinReservationHours('11:00', '21:00', '20:59')); // true\n// console.log(withinReservationHours('11:00', '21:00', '21:01')); // false\n// console.log(withinReservationHours('11:00', '21:00', '10:59')); // false\n\n/**\n * Takes in the minutes in `hh:mm` format and returns the rounded time\n * @param {string} minutes\n * @param {number} factor\n * @returns `string`\n *\n * Example: with `factor: 15`\n * ---------------------------\n * Input: `23:37` => Output: `23:30`\n * Input: `23:38` => Output: `23:45`\n * Input: `23:52` => Output: `23:45`\n * Input: `23:53` => Output: `24:00`\n */\nexport const roundTime = (minutes, factor) => {\n  const slots = 60 / factor;\n  const [hh, mm] = minutes.split(':');\n  const MM = Math.round(mm / factor) * factor % 60;\n  if (MM > 0 || mm < 60 / slots / 2) return `${hh}:${(MM + '0').slice(0, 2)}`;else {\n    return `${Math.min(Number(hh) + 1, 24)}:${MM}0`;\n  }\n};\n\n// console.log(roundTime('12:04', 15)); // 12:00\n// console.log(roundTime('23:37', 15)); // 23:30\n// console.log(roundTime('23:38', 15)); // 23:45\n// console.log(roundTime('23:52', 15)); // 23:45\n// console.log(roundTime('23:53', 15)); // 24:00\n\nexport const normalizeAvailability = availableTimes => availableTimes === null || availableTimes === void 0 ? void 0 : availableTimes.map((t, i) => ({\n  id: i + 1,\n  label: t,\n  value: t\n}));","map":{"version":3,"names":["compareDates","startDate","endDate","offsetDays","d1","Date","d2","parseInt","setDate","getDate","Math","round","max","currentDateTime","dateTime","date","toLocaleDateString","time","toLocaleTimeString","split","reverse","join","slice","lastIndexOf","convertToMilliseconds","tArr","reduce","acc","num","index","pow","length","withinReservationHours","startTime","endTime","value","t1","t2","v","roundTime","minutes","factor","slots","hh","mm","MM","min","Number","normalizeAvailability","availableTimes","map","t","i","id","label"],"sources":["/Users/mplussoftware/Public/coursera/meta-frondtend-capstone-project/src/utilities/datetime-helpers.js"],"sourcesContent":["/**\n * Compares Two Dates against each other with any offset and\n * returns whether the first date is still lesser than the second with offset factored in.\n * @param {Date} startDate\n * @param {Date} endDate\n * @param {Number} offsetDays\n * @returns `boolean`\n *\n * Examples:\n * ---------\n * `compareDates('2023/01/30', '2023/01/31', 1);` ==> `false`\n * `compareDates('2023/01/28', '2023/01/31', 2);` ==> `true`\n * `console.log(compareDates(Date.now(), '2023/02/12', 1));` ==> true\n */\nexport const compareDates = (startDate, endDate, offsetDays = 0) => {\n  const d1 = new Date(startDate);\n  const d2 = new Date(endDate);\n\n  if (!parseInt(offsetDays)) return d1 < d2;\n  else {\n    d1.setDate(d1.getDate() + Math.round(Math.max(offsetDays, 0)));\n    return d1 < d2;\n  }\n};\n\n/**\n * Gets the current date and time formatted for the HTML Input date and time fields.\n * Takes in an offsetDays to return a date in the future or past.\n * @param {number} offset\n * @returns\n */\nexport const currentDateTime = (offsetDays = 0) => {\n  const dateTime = new Date();\n  dateTime.setDate(dateTime.getDate() + Math.round(offsetDays));\n  const date = dateTime.toLocaleDateString();\n  const time = dateTime.toLocaleTimeString();\n\n  return {\n    date: date.split('/').reverse().join('-'),\n    time: time.slice(0, time.lastIndexOf(':')),\n  };\n};\n\n/**\n * Given time in the format: `21:00` or `12:58:37`, convert the time to milliseconds.\n * @param {string} time\n * @returns\n */\nexport const convertToMilliseconds = time => {\n  const tArr = time.split(':');\n  return tArr.reduce((acc, num, index) => {\n    if (index > 1) return acc + num;\n    return acc + num * Math.pow(60, tArr.length - index);\n  }, 0);\n};\n\n/**\n * Takes a `startTime` and an `endTime` and compares them against a time to check if it\n * is a valid time of if doesn't fall within the time period.\n * @param {string} startTime\n * @param {string} endTime\n * @param {string} value\n * @returns `boolean`\n */\nexport const withinReservationHours = (startTime, endTime, value) => {\n  const t1 = convertToMilliseconds(startTime);\n  const t2 = convertToMilliseconds(endTime);\n  const v = convertToMilliseconds(value);\n\n  return v >= t1 && v <= t2;\n};\n\n// console.log(withinReservationHours('11:00', '21:00', '11:00')); // true\n// console.log(withinReservationHours('11:00', '21:00', '21:00')); // true\n// console.log(withinReservationHours('11:00', '21:00', '20:59')); // true\n// console.log(withinReservationHours('11:00', '21:00', '21:01')); // false\n// console.log(withinReservationHours('11:00', '21:00', '10:59')); // false\n\n/**\n * Takes in the minutes in `hh:mm` format and returns the rounded time\n * @param {string} minutes\n * @param {number} factor\n * @returns `string`\n *\n * Example: with `factor: 15`\n * ---------------------------\n * Input: `23:37` => Output: `23:30`\n * Input: `23:38` => Output: `23:45`\n * Input: `23:52` => Output: `23:45`\n * Input: `23:53` => Output: `24:00`\n */\nexport const roundTime = (minutes, factor) => {\n  const slots = 60 / factor;\n  const [hh, mm] = minutes.split(':');\n\n  const MM = (Math.round(mm / factor) * factor) % 60;\n  if (MM > 0 || mm < 60 / slots / 2) return `${hh}:${(MM + '0').slice(0, 2)}`;\n  else {\n    return `${Math.min(Number(hh) + 1, 24)}:${MM}0`;\n  }\n};\n\n// console.log(roundTime('12:04', 15)); // 12:00\n// console.log(roundTime('23:37', 15)); // 23:30\n// console.log(roundTime('23:38', 15)); // 23:45\n// console.log(roundTime('23:52', 15)); // 23:45\n// console.log(roundTime('23:53', 15)); // 24:00\n\nexport const normalizeAvailability = availableTimes =>\n  availableTimes?.map((t, i) => ({\n    id: i + 1,\n    label: t,\n    value: t,\n  }));\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}